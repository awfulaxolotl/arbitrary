import { repeat } from 'ramda'
import { Sampler, number, compose } from '../..'
import create from '../../create'
import vector from '../vector'

/**
 * Sampler for arrays
 *
 * Elements are generated by the specified sampler. Expands in size
 * as the input grows.
 *
 * Uses the `vector` sampler internally to do decent coverage of the
 * combinations between the independent element subsamplers.
 *
 * @param element Sampler for array elements
 * @param options Configure how arrays are generated
 */
export default function array<T>(
  element: Sampler<T>,
  options?: ArrayOptions,
): Sampler<T[]> {
  const { maxLength = 25 } = options || {}
  const leaves = maxLength + 1
  const length = compose(Math.floor, number({ min: 0, max: maxLength }))

  const gen = (point: number) => {
    const chunkSize = 1 / maxLength
    const lengthPoint = (point % chunkSize) / chunkSize
    const subpoints = vector(repeat(1, length(point)))(lengthPoint)
    return subpoints.map(p => element(p))
  }

  return create(gen, leaves)
}

export interface ArrayOptions {
  maxLength: number
}
